(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const n of i)if(n.type==="childList")for(const a of n.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&s(a)}).observe(document,{childList:!0,subtree:!0});function e(i){const n={};return i.integrity&&(n.integrity=i.integrity),i.referrerPolicy&&(n.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?n.credentials="include":i.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function s(i){if(i.ep)return;i.ep=!0;const n=e(i);fetch(i.href,n)}})();class y{x;y;constructor(t,e){this.x=t,this.y=e}add(t){return this.x+=t.x,this.y+=t.y,this}sub(t){return this.x-=t.x,this.y-=t.y,this}mult(t){return this.x*=t,this.y*=t,this}div(t){return this.x/=t,this.y/=t,this}mag(){return Math.sqrt(this.x*this.x+this.y*this.y)}limit(t){if(this.mag()>t){const e=this.getNormalized();this.x=e.x*t,this.y=e.y*t}return this}getNormalized(){const t=this.mag();return t!==0?new y(this.x/t,this.y/t):new y(0,0)}heading(){return Math.atan2(this.y,this.x)}rotated(t){const e=this.heading()+t,s=this.mag();return new y(Math.cos(e)*s,Math.sin(e)*s)}rotateInPlace(t){const e=this.heading()+t,s=this.mag();return this.x=Math.cos(e)*s,this.y=Math.sin(e)*s,this}dist(t){const e=this.x-t.x,s=this.y-t.y;return Math.sqrt(e*e+s*s)}copy(){return new y(this.x,this.y)}static fromAngle(t,e=1){return new y(Math.cos(t)*e,Math.sin(t)*e)}}function F(o){return function(){let t=o+=1831565813;return t=Math.imul(t^t>>>15,t|1),t^=t+Math.imul(t^t>>>7,t|61),((t^t>>>14)>>>0)/4294967296}}class x{innerWalls=[];outerWalls=[];checkpoints=[];startPoint=new y(0,0);startAngle=0;seed=0;centerLine=[];trackWidth=120;static FIXED_SIZE=1200;constructor(t,e,s=0){this.seed=s,this.generateSimpleLoopedTrack(x.FIXED_SIZE,x.FIXED_SIZE,s)}generateControlPoints(t,e,s){const i=t/2,n=e/2,a=14,r=Math.min(t,e)*.35,l=r*.75,c=r*1,h=.08,d=[];for(let u=0;u<a;u++){const f=u/a*Math.PI*2;let p=0;s()>.92&&(p=(s()>.5?1:-1)*s()*h*(Math.PI*2/a));const S=f+p,w=c-l,g=l+s()*w,v=i+g*Math.cos(S),N=n+g*Math.sin(S);d.push(new y(v,N))}return d}catmullRomSpline(t,e){const s=[],i=t.length;for(let n=0;n<i;n++){const a=t[(n-1+i)%i],r=t[n],l=t[(n+1)%i],c=t[(n+2)%i];for(let h=0;h<e;h++){const d=h/e,u=d*d,f=u*d,p=.5*((-a.x+3*r.x-3*l.x+c.x)*f+(2*a.x-5*r.x+4*l.x-c.x)*u+(-a.x+l.x)*d+2*r.x),S=.5*((-a.y+3*r.y-3*l.y+c.y)*f+(2*a.y-5*r.y+4*l.y-c.y)*u+(-a.y+l.y)*d+2*r.y);s.push(new y(p,S))}}return s}calculateNormal(t,e,s){const i=e.x-t.x,n=e.y-t.y,a=Math.sqrt(i*i+n*n),r=a>0?i/a:0,l=a>0?n/a:0,c=s.x-e.x,h=s.y-e.y,d=Math.sqrt(c*c+h*h),u=d>0?c/d:0,f=d>0?h/d:0,p=r+u,S=l+f,w=Math.sqrt(p*p+S*S),g=w>0?p/w:0,v=w>0?S/w:0;return new y(-v,g)}generateWallsFromCenterLine(){this.innerWalls=[],this.outerWalls=[],this.checkpoints=[];const t=this.trackWidth/2,e=this.centerLine.length,s=[];let i=null;for(let c=0;c<e;c++){const h=this.centerLine[(c-1+e)%e],d=this.centerLine[c],u=this.centerLine[(c+1)%e];let f=this.calculateNormal(h,d,u);i&&f.x*i.x+f.y*i.y<0&&(f=new y(-f.x,-f.y)),s.push(f),i=f}if(e>1){const c=s[0],h=s[e-1];c.x*h.x+c.y*h.y<0&&(s[0]=new y(-c.x,-c.y))}let n=null,a=null,r=null,l=null;for(let c=0;c<e;c++){const h=this.centerLine[c],d=s[c],u=new y(h.x-d.x*t,h.y-d.y*t),f=new y(h.x+d.x*t,h.y+d.y*t);c===0&&(n=u,a=f),r&&l&&(this.innerWalls.push([r,u]),this.outerWalls.push([l,f]),this.checkpoints.push([u,f])),r=u,l=f}r&&l&&n&&a&&(this.innerWalls.push([r,n]),this.outerWalls.push([l,a]),this.checkpoints.push([n,a]))}findStartPoint(){if(this.checkpoints.length>0){const t=this.checkpoints[0],e=t[0],s=t[1];this.startPoint=new y((e.x+s.x)/2,(e.y+s.y)/2);const i=s.x-e.x,n=s.y-e.y;this.startAngle=Math.atan2(-i,n)}else this.startPoint=new y(x.FIXED_SIZE/2,x.FIXED_SIZE/2),this.startAngle=0}segmentsIntersect(t,e,s,i){const n=e.x-t.x,a=e.y-t.y,r=i.x-s.x,l=i.y-s.y,c=n*l-a*r;if(Math.abs(c)<1e-10)return!1;const h=s.x-t.x,d=s.y-t.y,u=(h*l-d*r)/c,f=(h*a-d*n)/c;return u>.01&&u<.99&&f>.01&&f<.99}hasSelfIntersection(){const t=this.centerLine.length;for(let e=0;e<t;e++){const s=this.centerLine[e],i=this.centerLine[(e+1)%t];for(let n=e+3;n<t-1;n++){const a=this.centerLine[n],r=this.centerLine[(n+1)%t];if(this.segmentsIntersect(s,i,a,r))return!0}}return!1}hasWallIntersection(){const t=this.innerWalls.length;for(let e=0;e<t;e++){const s=this.innerWalls[e];for(let i=0;i<t;i++){if(Math.abs(e-i)<=1||Math.abs(e-i)>=t-1)continue;const n=this.outerWalls[i];if(this.segmentsIntersect(s[0],s[1],n[0],n[1]))return!0}}for(let e=0;e<t;e++){const s=this.innerWalls[e],i=this.outerWalls[e];for(let n=e+3;n<t-1;n++){const a=this.innerWalls[n],r=this.outerWalls[n];if(this.segmentsIntersect(s[0],s[1],a[0],a[1])||this.segmentsIntersect(i[0],i[1],r[0],r[1]))return!0}}return!1}generateSimpleLoopedTrack(t,e,s=0){this.innerWalls=[],this.outerWalls=[],this.checkpoints=[],this.centerLine=[],this.seed=s;const i=s>0?F(s):null;let n=0;const a=20;for(;n<a;){const r=this.generateControlPoints(t,e,i||(()=>Math.random())),l=15;if(this.centerLine=this.catmullRomSpline(r,l),this.hasSelfIntersection()){n++,n<a&&(this.seed=s+n*1e3);continue}if(this.generateWallsFromCenterLine(),this.hasWallIntersection()){n++,n<a&&(this.seed=s+n*1e3);continue}break}this.findStartPoint()}randomize(t,e){const s=Math.floor(Math.random()*1e6)+1;return this.generateSimpleLoopedTrack(t,e,s),s}draw(t){t.lineWidth=4,t.strokeStyle="#fff",t.beginPath();for(const e of this.outerWalls)t.moveTo(e[0].x,e[0].y),t.lineTo(e[1].x,e[1].y);t.stroke(),t.beginPath();for(const e of this.innerWalls)t.moveTo(e[0].x,e[0].y),t.lineTo(e[1].x,e[1].y);t.stroke(),this.checkpoints.length>0&&(t.strokeStyle="rgba(0, 255, 0, 0.5)",t.lineWidth=2,t.beginPath(),t.moveTo(this.checkpoints[0][0].x,this.checkpoints[0][0].y),t.lineTo(this.checkpoints[0][1].x,this.checkpoints[0][1].y),t.stroke())}}function T(o,t,e,s){const i=(s.x-e.x)*(o.y-e.y)-(s.y-e.y)*(o.x-e.x),n=(e.y-o.y)*(o.x-t.x)-(e.x-o.x)*(o.y-t.y),a=(s.y-e.y)*(t.x-o.x)-(s.x-e.x)*(t.y-o.y);if(a!==0){const r=i/a,l=n/a;if(r>=0&&r<=1&&l>=0&&l<=1)return{x:o.x+r*(t.x-o.x),y:o.y+r*(t.y-o.y),offset:r}}return null}class O{pos;vel;acc;maxSpeed=5;maxForce=.2;radius=8;heading;isDead=!1;fitness=0;distanceTraveled=0;checkpointCount=0;life=500;sensorCount=5;sensorRays=[];sensorDistances=[];sensorAngles=[-Math.PI/2,-Math.PI/4,0,Math.PI/4,Math.PI/2];sensorLength=100;network;lastInputs=[0,0,0,0,0];lastOutputs=[0,0];lastHiddenActivations=[[0,0,0,0],[0,0,0,0]];constructor(t,e,s){this.pos=new y(t,e),this.vel=y.fromAngle(s,.1),this.acc=new y(0,0),this.heading=s,this.network=new brain.NeuralNetwork({hiddenLayers:[4,4],activation:"sigmoid"}),this.network.train([{input:[0,0,0,0,0],output:[.5,.5]}],{iterations:1}),this.scrambleWeights()}scrambleWeights(){const t=this.network.toJSON();for(let e=0;e<t.layers.length;e++){const s=t.layers[e];if(s.weights){for(let i=0;i<s.weights.length;i++)for(let n=0;n<s.weights[i].length;n++)s.weights[i][n]=Math.random()*4-2;if(s.biases)for(let i=0;i<s.biases.length;i++)s.biases[i]=Math.random()*4-2}}this.network.fromJSON(t)}calculateHiddenActivations(t){const e=this.network.toJSON();let s=t;for(let i=1;i<e.layers.length;i++){const n=e.layers[i];if(!n.weights)continue;const a=[];for(let r=0;r<n.weights.length;r++){let l=n.biases&&n.biases[r]||0;for(let c=0;c<s.length;c++)l+=(n.weights[r][c]||0)*s[c];a.push(1/(1+Math.exp(-l)))}s=a,i<e.layers.length-1&&(this.lastHiddenActivations[i-1]=a)}}update(t){if(this.isDead||(this.updateSensors(t),this.checkCollisions(t),this.isDead))return;const e=this.sensorDistances.map(l=>l/this.sensorLength);this.lastInputs=e;const s=this.network.run(e);this.lastOutputs=s,this.calculateHiddenActivations(e);const i=s[0],n=s[1]*2-1;this.heading+=n*.1;const a=y.fromAngle(this.heading,i*this.maxForce);this.acc.add(a),this.vel.add(this.acc),this.vel.limit(this.maxSpeed),this.vel=this.vel.mult(.95);const r=new y(this.pos.x,this.pos.y);if(this.pos.add(this.vel),this.acc.mult(0),this.life--,this.life<=0){this.isDead=!0;return}this.checkCheckpoints(t,r),this.distanceTraveled+=this.vel.mag(),this.fitness=this.checkpointCount*1e3+this.distanceTraveled}checkCheckpoints(t,e){const s=this.checkpointCount%t.checkpoints.length,i=t.checkpoints[s];T(e,this.pos,i[0],i[1])&&(this.checkpointCount++,this.life+=500,this.life>1e3&&(this.life=1e3))}updateSensors(t){this.sensorRays=[],this.sensorDistances=[];const e=[...t.innerWalls,...t.outerWalls];for(let s=0;s<this.sensorCount;s++){const i=this.heading+this.sensorAngles[s],n=y.fromAngle(i,this.sensorLength),a=new y(this.pos.x+n.x,this.pos.y+n.y);let r=null,l=this.sensorLength;for(const c of e){const h=T(this.pos,a,c[0],c[1]);if(h){const d=this.pos.dist(new y(h.x,h.y));d<l&&(l=d,r=new y(h.x,h.y))}}this.sensorDistances.push(l),r?this.sensorRays.push(r):this.sensorRays.push(a)}}checkCollisions(t){const e=[...t.innerWalls,...t.outerWalls],s=new y(this.pos.x+this.vel.x,this.pos.y+this.vel.y);for(const i of e)if(T(this.pos,s,i[0],i[1])){this.isDead=!0;return}for(let i of this.sensorDistances)if(i<this.radius){this.isDead=!0;return}}draw(t,e=!1){if(!this.isDead){if(e){t.lineWidth=1;for(let s=0;s<this.sensorRays.length;s++){const i=this.sensorDistances[s]/this.sensorLength,n=Math.floor(255*(1-i)),a=Math.floor(255*i);t.strokeStyle=`rgba(${n}, ${a}, 0, 0.5)`,t.beginPath(),t.moveTo(this.pos.x,this.pos.y),t.lineTo(this.sensorRays[s].x,this.sensorRays[s].y),t.stroke()}}t.translate(this.pos.x,this.pos.y),t.rotate(this.heading),t.fillStyle=e?"#00ff00":"rgba(200, 200, 200, 0.5)",t.beginPath(),t.moveTo(this.radius,0),t.lineTo(-this.radius,-this.radius/1.5),t.lineTo(-this.radius,this.radius/1.5),t.closePath(),t.fill(),t.rotate(-this.heading),t.translate(-this.pos.x,-this.pos.y)}}}class W{populationSize=50;mutationRate=.1;boids=[];generation=1;timer=0;maxLifespan=2e3;eliteCount=1;tournamentSize=3;topParentsCount=5;constructor(t,e,s,i){this.populationSize=t;const n=localStorage.getItem("best_boid_brain"),a=localStorage.getItem("current_generation");a&&(this.generation=parseInt(a));for(let r=0;r<t;r++){const l=new O(e,s,i);if(n&&r===0)l.network.fromJSON(JSON.parse(n));else if(n&&r<t*.2){const c=JSON.parse(n);this.mutate(c,.2),l.network.fromJSON(c)}this.boids.push(l)}}update(t){this.timer++;let e=!0;for(const s of this.boids)s.update(t),s.isDead||(e=!1);(e||this.timer>this.maxLifespan)&&(this.nextGeneration(t.startPoint.x,t.startPoint.y,t.startAngle),this.timer=0)}selectParent(){let t=null;for(let e=0;e<this.tournamentSize;e++){const s=Math.floor(Math.random()*this.boids.length),i=this.boids[s];(!t||i.fitness>t.fitness)&&(t=i)}return t}crossover(t,e){const s=JSON.parse(JSON.stringify(t));for(let i=0;i<s.layers.length;i++){const n=s.layers[i],a=e.layers[i];if(n.weights&&a?.weights)for(let r=0;r<n.weights.length;r++)for(let l=0;l<n.weights[r].length;l++){const c=Math.random();n.weights[r][l]=n.weights[r][l]*c+a.weights[r][l]*(1-c)}if(n.biases&&a?.biases)for(let r=0;r<n.biases.length;r++){const l=Math.random();n.biases[r]=n.biases[r]*l+a.biases[r]*(1-l)}}return s}nextGeneration(t,e,s){this.boids.sort((r,l)=>l.fitness-r.fitness);const i=[],n=this.boids[0];for(let r=0;r<this.eliteCount&&r<this.boids.length;r++){const l=new O(t,e,s);l.network.fromJSON(this.boids[r].network.toJSON()),i.push(l)}const a=Math.floor(this.populationSize*.2);for(let r=i.length;r<a;r++){const l=new O(t,e,s),c=n.network.toJSON();this.mutate(c,.2),l.network.fromJSON(c),i.push(l)}for(;i.length<this.populationSize;){const r=new O(t,e,s),l=this.selectParent(),c=this.selectParent(),h=l.network.toJSON(),d=c.network.toJSON(),u=this.crossover(h,d);this.mutate(u,this.mutationRate),r.network.fromJSON(u),i.push(r)}this.boids=i,this.generation++,localStorage.setItem("best_boid_brain",JSON.stringify(n.network.toJSON())),localStorage.setItem("current_generation",this.generation.toString())}mutate(t,e){for(let s=0;s<t.layers.length;s++){const i=t.layers[s];if(i.weights){for(let n=0;n<i.weights.length;n++)for(let a=0;a<i.weights[n].length;a++)Math.random()<e&&(i.weights[n][a]+=Math.random()*2-1);if(i.biases)for(let n=0;n<i.biases.length;n++)Math.random()<e&&(i.biases[n]+=Math.random()*2-1)}}}getBestActiveBoid(){let t=null,e=-1;for(let s of this.boids)s.fitness>e&&(e=s.fitness,t=s);return t}calculateDiversity(){if(this.boids.length<2)return 0;const t=Math.min(10,this.boids.length),e=[];for(let n=0;n<t;n++){const a=Math.floor(Math.random()*this.boids.length);e.push(this.boids[a].network.toJSON())}let s=0,i=0;for(let n=0;n<e.length;n++)for(let a=n+1;a<e.length;a++)s+=this.networkDistance(e[n],e[a]),i++;return i>0?s/i:0}networkDistance(t,e){let s=0;for(let i=0;i<t.layers.length;i++){const n=t.layers[i],a=e.layers[i];if(n.weights&&a.weights)for(let r=0;r<n.weights.length;r++)for(let l=0;l<n.weights[r].length;l++){const c=(n.weights[r][l]||0)-(a.weights[r]?.[l]||0);s+=c*c}if(n.biases&&a.biases)for(let r=0;r<n.biases.length;r++){const l=(n.biases[r]||0)-(a.biases[r]||0);s+=l*l}}return Math.sqrt(s)}}function $(o){const t=[];o.layers[1]?.weights?.[0]&&t.push(o.layers[1].weights[0].length);for(let e=1;e<o.layers.length;e++){const s=o.layers[e];s.biases&&t.push(s.biases.length)}return t}function j(o,t){const e=t.network.toJSON();if(!e.layers||e.layers.length===0)return;const s=o.canvas.width,i=o.canvas.height;console.log("Network JSON:",e),console.log("Layers count:",e.layers.length),e.layers.forEach((h,d)=>{console.log(`Layer ${d}: weights=${h.weights?.length}x${h.weights?.[0]?.length}, biases=${h.biases?.length}`)});const n=$(e);if(o.fillStyle="#666",o.font="10px Arial",o.textAlign="left",o.fillText(`Topology: ${n.join(" -> ")}`,5,i-5),o.fillText(`Layers: ${e.layers.length}`,5,i-18),n.length===0)return;const a=s/n.length,r=Math.min(14,(i-100)/(Math.max(...n)*2.5)),l=[];for(let h=0;h<n.length;h++){const d=n[h],u=a*h+a/2,f=[],p=(i-80)/(d+1),S=50;for(let w=0;w<d;w++){const g=S+(w+1)*p;f.push({x:u,y:g})}l.push(f)}o.fillStyle="#aaa",o.font="11px Arial",o.textAlign="center";const c=["Input","Hidden 1","Hidden 2","Output"];for(let h=0;h<n.length;h++){const d=a*h+a/2;o.fillText(c[h]||"",d,20),o.fillStyle="#666",o.font="9px Arial",o.fillText(`(${n[h]} nodes)`,d,32),o.fillStyle="#aaa",o.font="11px Arial"}for(let h=1;h<n.length;h++){const d=n[h],u=n[h-1],f=e.layers[h];for(let p=0;p<d;p++){const S=l[h][p];for(let w=0;w<u;w++){const g=l[h-1][w];let v=0;f&&f.weights&&f.weights[p]&&(v=f.weights[p][w]||0);const N=Math.min(1,Math.abs(v)/3);N>.02&&(o.beginPath(),o.lineWidth=1+Math.abs(v)*.5,v>0?o.strokeStyle=`rgba(50, 255, 100, ${N})`:o.strokeStyle=`rgba(255, 80, 80, ${N})`,o.moveTo(g.x,g.y),o.lineTo(S.x,S.y),o.stroke())}}}for(let h=0;h<l.length;h++)for(let d=0;d<l[h].length;d++){const u=l[h][d];let f=.5;if(h===0&&t.lastInputs[d]!==void 0)f=t.lastInputs[d];else if(h===l.length-1&&t.lastOutputs[d]!==void 0)f=t.lastOutputs[d];else if(h>0&&h<l.length-1){const g=h-1;t.lastHiddenActivations[g]&&t.lastHiddenActivations[g][d]!==void 0&&(f=t.lastHiddenActivations[g][d])}f>.6?(o.shadowBlur=20,o.shadowColor=`rgba(0, 255, 200, ${f})`):f<.4&&(o.shadowBlur=10,o.shadowColor=`rgba(255, 100, 100, ${1-f})`),o.beginPath(),o.arc(u.x,u.y,r,0,Math.PI*2);let p,S,w;if(f<.5){const g=f*2;p=Math.floor(50*(1-g)+50*g),S=Math.floor(100*(1-g)+200*g),w=Math.floor(200*(1-g)+100*g)}else{const g=(f-.5)*2;p=Math.floor(50*(1-g)+255*g),S=Math.floor(200*(1-g)+200*g),w=Math.floor(100*(1-g)+50*g)}if(o.fillStyle=`rgb(${p}, ${S}, ${w})`,o.fill(),o.shadowBlur=0,o.strokeStyle="#fff",o.lineWidth=2,o.stroke(),o.fillStyle="#fff",o.font="bold 8px Arial",o.textAlign="center",o.textBaseline="middle",o.fillText(f.toFixed(2),u.x,u.y),o.fillStyle="#888",o.font="8px Arial",o.textBaseline="top",h===0){const g=["L","FL","F","FR","R"];o.fillText(g[d]||`S${d+1}`,u.x,u.y+r+2)}else if(h===l.length-1){const g=["Thr","Str"];o.fillText(g[d]||`O${d+1}`,u.x,u.y+r+2)}}}let k,M,I,L,P=!1,J=!1,z=10,b,m;const E=50;function A(){k=document.getElementById("simulation-canvas"),I=document.getElementById("network-canvas");const o=x.FIXED_SIZE;k.width=o,k.height=o;const t=document.getElementById("network-container");t&&(I.width=t.clientWidth-20,I.height=t.clientHeight-20),M=k.getContext("2d"),L=I.getContext("2d"),b=new x(k.width,k.height),m=new W(E,b.startPoint.x,b.startPoint.y,b.startAngle);const e=document.getElementById("btn-toggle-fast");e?.addEventListener("click",()=>{P=!P,e&&(e.innerText=P?"Toggle Normal Viz":"Toggle Fast Training (No Render)")}),document.getElementById("btn-restart")?.addEventListener("click",()=>{m=new W(E,b.startPoint.x,b.startPoint.y,b.startAngle),m.generation=1}),document.getElementById("btn-clear-history")?.addEventListener("click",()=>{confirm("Clear all training history? This will reset the brain.")&&(localStorage.removeItem("best_boid_brain"),localStorage.removeItem("current_generation"),m=new W(E,b.startPoint.x,b.startPoint.y,b.startAngle),m.generation=1)}),document.getElementById("btn-randomize-track")?.addEventListener("click",()=>{const i=b.randomize(x.FIXED_SIZE,x.FIXED_SIZE);R(i),X()}),document.getElementById("auto-randomize")?.addEventListener("change",i=>{J=i.target.checked}),document.getElementById("btn-export-brain")?.addEventListener("click",()=>{_()}),document.getElementById("btn-import-brain")?.addEventListener("click",()=>{H()}),requestAnimationFrame(C)}function X(){for(const o of m.boids)o.pos=new y(b.startPoint.x,b.startPoint.y),o.heading=b.startAngle,o.vel=y.fromAngle(b.startAngle,.1),o.acc.mult(0),o.isDead=!1,o.fitness=0,o.distanceTraveled=0,o.checkpointCount=0,o.life=500;m.timer=0}function _(){const o=m.boids.reduce((a,r)=>r.fitness>a.fitness?r:a,m.boids[0]);if(!o)return;const t=o.network.toJSON(),e={generation:m.generation,fitness:o.fitness,network:t,exportedAt:new Date().toISOString()},s=new Blob([JSON.stringify(e,null,2)],{type:"application/json"}),i=URL.createObjectURL(s),n=document.createElement("a");n.href=i,n.download=`brain-gen${m.generation}-fitness${Math.floor(o.fitness)}.json`,document.body.appendChild(n),n.click(),document.body.removeChild(n),URL.revokeObjectURL(i)}function H(){const o=document.createElement("input");o.type="file",o.accept=".json",o.onchange=async t=>{const e=t.target.files?.[0];if(e)try{const s=await e.text(),i=JSON.parse(s);if(!i.network||!i.network.layers){alert("Invalid brain file: missing network structure");return}const n=m.boids[0];n&&(n.network.fromJSON(i.network),localStorage.setItem("best_boid_brain",JSON.stringify(i.network)),i.generation&&(m.generation=i.generation,localStorage.setItem("current_generation",i.generation.toString())),alert(`Brain imported successfully! Generation: ${i.generation||"unknown"}, Fitness: ${Math.floor(i.fitness)||"unknown"}`))}catch(s){alert("Failed to import brain: "+s.message)}},o.click()}function R(o){const t=document.getElementById("track-seed");t&&(t.innerText=o===0?"Default":o.toString())}function D(){const o=m.generation;if(m.update(b),J&&m.generation>o&&m.generation%z===0){const t=b.randomize(k.width,k.height);R(t)}}function B(){const o=document.getElementById("generation-count"),t=document.getElementById("alive-count"),e=document.getElementById("best-fitness"),s=document.getElementById("diversity-score");o&&(o.innerText=m.generation.toString());const i=m.boids.filter(a=>!a.isDead).length;t&&(t.innerText=`${i} / ${E}`);const n=m.getBestActiveBoid();if(n&&e&&(e.innerText=Math.floor(n.fitness).toString()),s&&m.timer%10===0){const a=m.calculateDiversity();s.innerText=a.toFixed(2),a<1?s.style.color="#ff6666":a<3?s.style.color="#ffaa66":s.style.color="#66ff66"}}function q(){M.clearRect(0,0,k.width,k.height),L.clearRect(0,0,I.width,I.height),b.draw(M);const o=m.getBestActiveBoid();for(const t of m.boids){const e=t===o;t.draw(M,e)}o&&(L.fillStyle="#222",L.fillRect(0,0,I.width,I.height),j(L,o)),B()}function C(){if(P){for(let o=0;o<20;o++)D();M.clearRect(0,0,k.width,k.height),M.fillStyle="white",M.fillText(`FAST TRAINING: GEN ${m.generation}`,20,30),B()}else D(),q();requestAnimationFrame(C)}document.readyState==="loading"?document.addEventListener("DOMContentLoaded",A):A();
